setImmediate corresponds to the check phase of Libuv. The submitted tasks will be executed in the check phase of the Libuv event loop. The tasks in the check stage will be executed in each round of the event loop, but the tasks submitted by setImmediate will only be executed once. Below we will see how Node.js works For processing, let's take a look at the specific implementation.

## 11.1 setImmediate

### 11.1.1 Set the function to process the immediate task When Node.js is initialized, set the function to process the immediate task ```js

     // runNextTicks is used to process the tasks generated by nextTick, and const { processImmediate, processTimers } = getTimerCallbacks(runNextTicks);
     setupTimers(processImmediate, processTimers);

`````


Let's take a look at the logic of setupTimers (timer.cc).

````cpp
    void SetupTimers(const FunctionCallbackInfo &amp; args) {
      auto env = Environment::GetCurrent(args);
      env-&gt;set_immediate_callback_function(args[0].As ());
      env-&gt;set_timers_callback_function(args[1].As ());
    }
`````

SetupTimers saves two functions processImmediate, processTimers in env, processImmediate handles immediate tasks, and processTimers handles timer tasks, which we have already analyzed in the timer chapter.

### 11.1.2 Registering the callback of the check phase When Node.js is initialized, the data structure and logic related to the immediate task are initialized at the same time.

```cpp
    void Environment::InitializeLibuv(bool start_profiler_idle_notifier) ​​{
      // Initialize immediate related handle
      uv_check_init(event_loop(), immediate_check_handle());
      // Modify the state to unref to avoid the exit of the event loop when there is no task uv_unref(reinterpret_cast (immediate_check_handle()));
      // Activate handle, set callback uv_check_start(immediate_check_handle(), CheckImmediate);
      // Also insert a related node in the idle phase uv_idle_init(event_loop(), immediate_idle_handle());
    }
```

Node.js will insert a node into the check phase by default, and set the callback to CheckImmediate, but the initialization state is unref, so if there is no immediate task, it will not affect the exit of the event loop. Let's take a look at the CheckImmediate function ````cpp
void Environment::CheckImmediate(uv_check_t* handle) {  
 // omit some code // no Immediate node to handle if (env-&gt;immediate_info()-&gt;count() == 0 ||  
 !env-&gt;can_call_into_js())  
 return;  
 do {  
 // Execute the JS layer callback immediate_callback_function  
 MakeCallback(env-&gt;isolate(),  
 env-&gt;process_object(),  
 env-&gt;immediate_callback_function(),  
 0,  
 nullptr,  
 {0, 0}).ToLocalChecked();  
 } while (env-&gt;immediate_info()-&gt;has_outstanding() &amp;&amp;  
 env-&gt;can_call_into_js());  
 /*  
 All immediate nodes have been processed, and the corresponding node in the idle phase is set to inactive state.
Allow Poll IO stage blocking and event loop exit \*/
if (env-&gt;immediate_info()-&gt;ref_count() == 0)  
 env-&gt;ToggleImmediateRef(false);  
 }

`````

We see that CheckImmediate is executed every time the event loop occurs, but returns directly if there are no tasks to process. If there is a task, the CheckImmediate function executes the immediate_callback_function function, which is the function processImmediate set when Node.js is initialized. After reading the logic of initializing and processing immediate tasks, let's see how to generate an immediate task.
### 11.1.3 setImmediate generates a task We can generate a task through setImmediate.

````js
    function setImmediate(callback, arg1, arg2, arg3) {
      let i, args;
      switch(arguments.length) {
        case 1:
          break;
        case 2:
          args = [arg1];
          break;
        case 3:
          args = [arg1, arg2];
          break;
        default:
          args = [arg1, arg2, arg3];
          for (i = 4; i &lt; arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
          break;
      }

      return new Immediate(callback, args);
    }
`````

The code of setImmediate is relatively simple, create a new Immediate. Let's take a look at the class Immediate.

```js
    const Immediate = class Immediate {
      constructor(callback, args) {
        this._idleNext = null;
        this._idlePrev = null;
        this._onImmediate = callback;
        this._argv = args;
        this._destroyed = false;
        this[kRefed] = false;
        this.ref();
        // The number of nodes in the Immediate linked list, including ref and unref status immediateInfo[kCount]++;
        // Join the linked list immediateQueue.append(this);
      }
      // Mark ref and insert an active node into Libuv's idle list, if not already ref() {
        if (this[kRefed] === false) {
          this[kRefed] = true;
          if (immediateInfo[kRefCount]++ === 0)
            toggleImmediateRef(true);
        }
        return this;
      }
      // Contrary to above unref() {
        if (this[kRefed] === true) {
          this[kRefed] = false;
          if (--immediateInfo[kRefCount] === 0)
            toggleImmediateRef(false);
        }
        return this;
      }

      hasRef() {
        return !!this[kRefed];
      }
    };
```

The Immediate class mainly does two things.

1 Generate a node and insert it into the linked list.

```js
    const immediateQueue = new ImmediateList();

    // Doubly acyclic linked list function ImmediateList() {
      this.head = null;
      this.tail = null;
    }
    ImmediateList.prototype.append = function(item) {
      // The tail pointer is not empty, indicating that the linked list is not empty, and it is directly appended to the tail node if (this.tail !== null) {
        this.tail._idleNext = item;
        item._idlePrev = this.tail;
      } else {
        // The tail pointer is empty, indicating that the linked list is empty, and the head and tail pointers both point to item
        this.head = item;
      }
      this.tail = item;
    };

    ImmediateList.prototype.remove = function(item) {
      // If the item is in the middle, it will retreat by itself, and connect the two nodes before and after if (item._idleNext !== null) {
        item._idleNext._idlePrev = item._idlePrev;
      }

      if (item._idlePrev !== null) {
        item._idlePrev._idleNext = item._idleNext;
      }
      // is the head pointer, you need to update the head pointer to point to the next item, because the item is deleted, the tail pointer is the same if (item === this.head)
        this.head = item._idleNext;
      if (item === this.tail)
        this.tail = item._idlePrev;
      // pointer before and after reset item._idleNext = null;
      item._idlePrev = null;
    };
```

2 If an activation node has not been inserted into Libuv's idle list, insert one. From the previous analysis, we know that Node.js inserts an unref node in the check phase, and executes the callback of the node in each check phase, so what is the use of this idle node? The answer is in the uv_backend_timeout function, uv_backend_timeout defines the duration of Poll IO blocking. If there is an idle node in the ref state, the Poll IO stage will not block (but it will not judge whether there is a check node). So when there is an immediate task, Node.js will insert this idle into the idle stage, indicating that there is task processing and cannot block the Poll IO stage. When there is no immediate task, the idle node is removed. In general, the meaning of the idle node is to mark whether there is an immediate task to be processed, and if so, it cannot block the Poll IO stage and cannot exit the event loop.

```cpp
    void ToggleImmediateRef(const FunctionCallbackInfo &amp; args) {
      Environment::GetCurrent(args)-&gt;ToggleImmediateRef(args[0]-&gt;IsTrue())
    }

    void Environment::ToggleImmediateRef(bool ref) {
      if (started_cleanup_) return;
      // Change the state of the handle (active or inactive) to prevent blocking in the Poll IO phase if (ref) {
        uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ });
      } else {
            // Do not block Poll IO, allow the event loop to exit uv_idle_stop(immediate_idle_handle());
      }
    }
```

This is the whole process of the setImmediate function. As with timers, we can call the immediate task's ref and unref functions to control its effect on the event loop.

### 11.1.4 Dealing with tasks generated by setImmediate Finally, let's take a look at how to deal with immediate tasks during the check phase. From the previous analysis, we know that the processImmediate function is the function that handles the immediate task, which comes from getTimerCallbacks (internal/timer.js).

`````js
    function processImmediate() {
       /*
           If processImmediate was last executed by an uncaught exception,
           Then outstandingQueue saves unexecuted nodes. The next time processImmediate is executed,
           The node that executes the outstandingQueue queue first */
       const queue = outstandingQueue.head !== null ?
         outstandingQueue : immediateQueue;
       let immediate = queue.head;
       /*
         When executing the immediateQueue queue, empty the queue first to avoid adding nodes to the queue when executing the callback, which is an infinite loop.t belongs to the timer stage, and setImmediate belongs to the check stage. The timer phase is executed earlier than the check in sequence. There is a very important detail in the implementation code of setTimeout.

````js
    after *= 1; // coalesce to number or NaN
      if (!(after &gt;= 1 &amp;&amp; after &lt;= TIMEOUT_MAX)) {
        if (after &gt; TIMEOUT_MAX) {
          process.emitWarning(`error message`);
        }
        after = 1; // schedule on next tick, follows browser behavior
      }
`````

We found that although the timeout we passed is 0, but 0 is not a legal value, Node.js will change the timeout to 1. This is what causes the output of the code above to be undefined. Let's analyze the execution process of this code. When Node.js starts, it compiles and executes the above code, starts a timer, and mounts a setImmediate node in the queue. Then enter the event loop of Libuv, and then execute the timer stage. Libuv judges whether 1 millisecond has elapsed since the timer was turned on. If so, execute the timer callback, otherwise execute the next node. After executing other stages, it will execute check stage. At this time, the callback of setImmediate will be executed. So, the output of the code at the beginning depends on whether 1 millisecond has elapsed from the time the timer is started to when Libuv executes the timer phase.

## 11.2 nextTick

nextTick is used to execute a callback function asynchronously, similar to setTimeout and setImmediate. The difference lies in their execution timing. The tasks of setTimeout and setImmediate are part of the event loop, but the tasks of nextTick are not part of the event loop. The specific execution timing We will analyze in this section.

### 11.2.1 Initialize nextTick

The nextTick function is mounted to the process object when executing bootstrap/node.js during Node.js startup.

```js
    const { nextTick, runNextTicks } = setupTaskQueue();
    process.nextTick = nextTick;
    // The real definition is in task_queues.js.
    setupTaskQueue() {
      setTickCallback(processTicksAndRejections);
      return {
        nextTick,
      };
    },
```

nextTick will be discussed next, setTickCallback is a function that registers and processes tick tasks.

```cpp
    static void SetTickCallback(const FunctionCallbackInfo &amp; args) {
      Environment* env = Environment::GetCurrent(args);
      CHECK(args[0]-&gt;IsFunction());
      env-&gt;set_tick_callback_function(args[0].As ());
    }
```

Just simply save the function that handles the tick task. ### 11.2.2 nextTick production task ```js will be used later
function nextTick(callback) {  
 let args;  
 switch(arguments.length) {  
 case 1: break;  
 case 2: args = [arguments[1]]; break;  
 case 3: args = [arguments[1], arguments[2]]; break;  
 case 4: args = [arguments[1], arguments[2], arguments[3]]; break;  
 default:  
 args = new Array(arguments.length - 1);  
 for (let i = 1; i &lt; arguments. length; i++)  
 args[i - 1] = arguments[i];  
 }  
 // The first task, open the tick processing logic if (queue.isEmpty())  
 setHasTickScheduled(true);  
 const asyncId = newAsyncId();  
 const triggerAsyncId = getDefaultTriggerAsyncId();  
 const tickObject = {  
 [async_id_symbol]: asyncId,  
 [trigger_async_id_symbol]: triggerAsyncId,  
 callback,  
 args  
 };  
 // Insert queue queue.push(tickObject);  
 }

`````

This is the logic when we execute nextTick. Each call to nextTick appends a node to the queue.
### 11.2.3 Handling tick tasks Let's take a look at the logic of handling tick tasks. When Nodejs is initialized, it registers the function to handle tick tasks by executing setTickCallback(processTicksAndRejections). Node.js saves the functions that handle tick tasks in env during initialization. In addition, Nodejs uses the TickInfo class to manage the logic of ticks.

````js
    class TickInfo : public MemoryRetainer {
     public:
      inline AliasedUint8Array&amp; fields();
      inline bool has_tick_scheduled() const;
      inline bool has_rejection_to_warn() const;
     private:
      inline explicit TickInfo(v8::Isolate* isolate);
      enum Fields { kHasTickScheduled = 0, kHasRejectionToWarn, kFieldsCount };

      AliasedUint8Array fields_;
    };
`````

TickInfo mainly has two flag bits, kHasTickScheduled marks whether there are tick tasks to be processed. Then execute the tick_callback_function through the object method Close function of the InternalCallbackScope class. When the bottom layer of Nodejs needs to execute a js callback, the MakeCallback of AsyncWrap will be called. InternalMakeCallback is called in MakeCallback.

```cpp
    MaybeLocal InternalMakeCallback(Environment* env, Local recv,
    const Local callback, int argc, Local argv[],
    async_context asyncContext) {
      InternalCallbackScope scope(env, recv, asyncContext);
      // Execute user layer js callback scope.Close();

      return ret;
    }
```

Let's look at Close of InternalCallbackScope

```cpp
    void InternalCallbackScope::Close() {
      // Omit some code TickInfo* tick_info = env_-&gt;tick_info();
      // If there is no tick task, you don't need to go down. When inserting a tick task, this will be set to true, and it will become false when there is no task.
      if (!tick_info-&gt;has_tick_scheduled() &amp;&amp; !tick_info-&gt;has_rejection_to_warn()) {
        return;
      }

      HandleScope``js
    function test() {
      process.nextTick(() =&gt; {
        console.log(1);
        test()
      });
    }
    test();

    setTimeout(() =&gt; {
     console.log(2)
    }, 10)
```

In the above code, 1 will always be output, but 2 will not be output. This problem has been dealt with in many places in the Nodejs source code. First, the task queue to be executed is moved to a variable q2, and the previous queue q1 is cleared. Then traverse the queue pointed to by q2. If a new node is added when the callback is executed, it will only be added to q1. q2 does not cause an infinite loop.

### 11.2.4 Use of nextTick We know that nextTick can be used to delay the execution of some logic, let's take a look at which scenarios nextTick can be used.

```js
    const { EventEmitter } = require('events');
    class DemoEvents extends EventEmitter {
      constructor() {
        super();
        this.emit('start');
      }
    }

    const demoEvents = new DemoEvents();
    demoEvents.on('start', () =&gt; {
      console.log('start');
    });
```

The above code will trigger the start event in the constructor, but the registration of the event is executed after the constructor. Before the constructor, we have not got the DemoEvents object, so the registration of the event cannot be completed. At this point, we can use nextTick.

```js
    const { EventEmitter } = require('events');
    class DemoEvents extends EventEmitter {
      constructor() {
        super();
        process.nextTick(() =&gt; {
          this.emit('start');
        })
      }
    }

    const demoEvents = new DemoEvents();
    demoEvents.on('start', () =&gt; {
      console.log('start');
    });
```
